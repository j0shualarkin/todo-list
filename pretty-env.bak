#lang racket/base

(require racket/format
         racket/dict
         racket/list
         syntax/id-table
         racket/match)


#;
(define-struct env ([types immutable-free-id-table?]
                    [obj-types (hash/c Object? Type? #:immutable #t)]
                    [props (listof Prop?)]
                    [aliases immutable-free-id-table?]))

(struct env [types obj-types props aliases])

(define ρ (env null (hash) '() null))




(define (longest-term ls)
  (define (term-length x)
    (string-length (~a x)))
  (let loop ([xs (cdr ls)]
             [long (term-length (car ls))])
    (define curr-term (term-length (car xs)))
    (if (> curr-term long)
        (loop (cdr xs) curr-term)
        (loop (cdr xs) long))
    long))

(define (format-term id sym val these)
  (format "~a ~a ~a\n"
          (~a (if (syntax? id) (syntax->datum id) id)
              #:min-width (longest-term these)
              #:align 'left)
          sym
          val))
  




(define (env->string ρ)
  (match-let ([(env T TO P A) ρ])
    (define types-in-scope (append (dict->list T) (hash->list TO)))
    (define (format-types id ty)
      (format-term id ': ty types-in-scope))
    (define (format-aliases x y)
      (format-term x '≡ y (dict->list A)))

    (apply string-append
     (flatten
      (list "Types:\n"
            (dict-map types-in-scope format-types)
            "\nPropositions:\n"
            (format "~a\n" P)
            "\nAliases:\n"
            (free-id-table-map A
                               format-aliases)
            "\n")))))


